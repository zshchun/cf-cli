#!/usr/bin/env python3
import tomli
import json
import sqlite3
import logging
import re
from Cryptodome.Cipher import AES
from time import time
from bs4 import BeautifulSoup
from datetime import datetime, timezone, timedelta
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from os import environ, path, mkdir, listdir, system, getcwd, sep
from sys import argv, exit
from operator import itemgetter
from urllib.parse import urlencode
from urllib.request import urlopen, Request, build_opener, HTTPCookieProcessor
from urllib.error import HTTPError
from http.cookiejar import CookieJar
__VERSION__ = "0.1"

class Codeforces:
    def __init__(self):
        basedir = environ["HOME"] + "/.cf-cli"
        config_path = basedir + "/config.toml"
        cookies = CookieJar()
        self.opener = build_opener(HTTPCookieProcessor(cookies))
        self.tz_msk = timezone(timedelta(hours=3))
        if path.isfile(config_path):
            self.conf = tomli.load(open(config_path, "rb"))
        else:
            self.conf = {'solved_dir': '~/codeforces', 'cache_dir': '~/codeforces/cache', 'lang_ext': ['cpp'], 'database': '~/codeforces/cache.db', 'title_width': 40, 'max_page': 3, 'open_in_browser': True, 'browser': 'google-chrome', 'pager': 'less', 'problem_range': {'1': [], '2': ['a', 'b'], '3': ['a', 'b', 'c', 'd'], '4': [], 'G': ['a', 'b']}}
        for d in [basedir, self.conf['solved_dir'], self.conf['cache_dir']]:
            if not path.isdir(path.expanduser(d)):
                mkdir(path.expanduser(d))
        self.domain = 'https://codeforces.com'
        self.headers = { 'Accept': '*/*', 'content-type': 'application/x-www-form-urlencoded', }
        database = path.expanduser(self.conf['database'])
        if not path.isfile(database):
            self.db = sqlite3.connect(database)
            cur = self.db.cursor()
            cur.execute('''CREATE TABLE codeforces (cid integer primary key, title varchar, authors varchar, start varchar, length varchar, participants integer, upcoming integer);''')
            cur.execute('''CREATE TABLE modifications (site TEXT NOT NULL PRIMARY KEY ON CONFLICT REPLACE, last_modified TIMESTAMP DEFAULT current_timestamp);''')
            cur.execute('''INSERT INTO modifications (site) VALUES ('codeforces');''')
            cur.execute('''CREATE TRIGGER update_time_codeforces AFTER UPDATE ON codeforces BEGIN UPDATE modifications SET last_modified = current_timestamp WHERE site = 'codeforces'; END;''')
            cur.execute('''CREATE TRIGGER delete_time_codeforces AFTER DELETE ON codeforces BEGIN UPDATE modifications SET last_modified = current_timestamp WHERE site = 'codeforces'; END;''')
            cur.execute('''CREATE TRIGGER insert_time_codeforces AFTER INSERT ON codeforces BEGIN UPDATE modifications SET last_modified = current_timestamp WHERE site = 'codeforces'; END;''')
            self.db.commit()
        else:
            self.db = sqlite3.connect(database)
 
    def http_get(self, path, headers=None):
        if headers == None: headers = self.headers
        if path.startswith('/'): path = self.domain + path
        req = Request(path, headers=headers);
        result = None
        with self.opener.open(req) as response:
            result = response.read()
        return result.decode('utf-8')

    def http_post(self, path, data, headers=None):
        if headers == None: headers = self.headers
        if path.startswith('/'): path = self.domain + path
        req = Request(path, headers=headers, data=urlencode(data).encode())
        result = None
        with self.opener.open(req) as response:
            result = response.read()
        return result.decode('utf-8')

    def view_submission(self, sid, prefix=''):
        json_path = "{}/{}-{}.json".format(path.expanduser(self.conf['cache_dir']), prefix, sid)
        if path.isfile(json_path):
            res = open(json_path, 'r').read()
        else:
            res = self.http_post("/data/submitSource", { 'submissionId':sid })
            open(json_path, 'w').write(res)
        print("[+] Cached:", json_path)
        js = json.loads(res)
        lang_ext = js['prettifyClass'][5:] if js['prettifyClass'].startswith('lang-') else js['prettifyClass']
        source_path = "{}/{}-{}.{}".format(path.expanduser(self.conf['cache_dir']), prefix, sid, lang_ext)
        open(source_path, 'w').write(js['source'])
        if "pager" in self.conf:
            print("[+] View source:", source_path)
            system(self.conf["pager"] + ' "' + source_path + '"')

    def get_solutions(self, args):
        cid = args.cid
        level = args.cid
        if not cid or not level:
            cid, level = self.get_cwd_info()
        if not cid or not level:
            print("[!] Invalid contestID or level")
            return
        post_data = { 'action':'setupSubmissionFilter', \
                'frameProblemIndex':level.upper(), \
                'verdictName':'OK', \
                'programTypeForInvoker':'anyProgramTypeForInvoker', \
                'comparisonType':'NOT_USED', \
                'judgedTestCount':'', \
                'participantSubstring':'', \
        }
#        order = 'BY_JUDGED_DESC'
        order = 'BY_ARRIVED_ASC'
        page = 1
        page_path = "/contest/{}/status/page/{}?order={}".format(cid, page, order)
        res = self.http_post(page_path, post_data)
        bs = BeautifulSoup(res, 'html.parser')
        table = bs.find("table", {"class": "status-frame-datatable"})
        tr = table.find_all("tr", {"data-submission-id": True})
        assert len(tr) > 0, "empty tr tag"
        for t in tr:
            td = t.find_all("td")
            assert len(td) > 6, "not enough td tags"
            url = self.domain + td[0].find('a', href=True)['href']
            sid = td[0].text.strip()
            when = datetime.strptime(td[1].find('span').text, "%b/%d/%Y %H:%M").replace(tzinfo=self.tz_msk).astimezone(tz=None).strftime('%y-%m-%d %H:%M')
            a = td[2].find('a', href=True)
#           TODO user color who['class']
            who = {'profile':a['href'],'class':a['class'][1],'title':a['title'],'name':a.text}
            problem = td[3].text.strip()
            lang = td[4].text.strip()
            verdict = td[5].text.strip()
            ms = td[6].text.strip()
            mem = td[7].text.strip()
            assert verdict == 'Accepted', 'submission was not accepted'
            print(sid, when, problem, who['name'], lang, ms, mem)
            choice = input("View this solution? [Y/n]").lower()
            if choice == "yes" or choice == 'y' or choice == '':
                r = self.view_submission(sid, str(cid)+level)

    def search_editorial(self, args):
        cid = args.cid
        if not cid:
            cid, _ = self.get_cwd_info()
        db = self.get_contest_info(cid)
        if not cid or not db:
            print("[!] Invalid contestID")
            return
        title = re.sub(r' ?\([^)]*\)', '', db[0])
        print("[+] Searching for", title, "editorial")
        res = self.http_post('/search', {'query': title + ' editorial' })
        bs = BeautifulSoup(res, 'html.parser')
        topics = bs.find_all("div", {"class": "topic"})
        finding_words = [t.lower() for t in title.split()] + ['editorial']
        posts = []
        for t in topics:
            div = t.find("div", {"class": "title"})
            page_title = div.a.text.strip()
            if page_title.lower().find('editorial') == -1: continue

            page_url = self.domain + div.find('a', href=True)['href']
            words = [t.lower() for t in page_title.split()]
            matches = sum(w in finding_words for w in words)
            posts += [{'title':page_title, 'url':page_url, 'match':matches}]

        posts.sort(key=itemgetter('match'), reverse=True)
        for p in posts:
            print("\n[+] Title: {}\n[+] URL : {}".format(p['title'], p['url']))
            if 'open_in_browser' in self.conf and self.conf['open_in_browser'] == True:
                system('''{} "{}"'''.format(self.conf['browser'], p['url']))

    def get_cwd_info(self):
        p = path.normpath(getcwd()).split(sep)
        if len(p) >= 2 and p[-2].isnumeric() and re.match(r"[a-z]", p[-1]):
            cid = int(p[-2])
            level = p[-1]
        elif len(p) >= 1 and p[-1].isnumeric():
            cid = int(p[-1])
            level = None
        else:
            cid = None
            level = None
        return cid, level

    def get_contest_info(self, cid):
        db = []
        if cid:
            cur = self.db.cursor()
            db = cur.execute(f'''SELECT title, authors, start, length, participants FROM codeforces WHERE cid = {cid};''').fetchone()
        return db

    def show_contest_info(self, args):
        if args.cid: 
            cid = int(args.cid)
            level = None
        else:
            cid, level = self.get_cwd_info()
        if cid:
            c = self.get_contest_info(cid)
            print("[+] Show contest info")
            if level:
                print("{}{} - {}".format(cid, level, c[0]))
            else:
                print("{} - {}".format(cid, c[0]))
        else:
            print("[!] ContestID not found.")

    def open_url(self, args):
        if not args.cid: return
        problems_url = "{}/contest/{}/problems".format(self.domain, args.cid)
        contest_url = "{}/contest/{}".format(self.domain, args.cid)
        print("[+] Open", contest_url)
        print("[+] Open", problems_url)
        if 'open_in_browser' in self.conf and self.conf['open_in_browser'] == True:
            system('''{} "{}" "{}"'''.format(self.conf['browser'], contest_url, problems_url))

    def parse_list(self, raw_contests, upcoming=0, write_db=True):
        cur = self.db.cursor()
        last_contest = cur.execute('''SELECT cid, start FROM codeforces WHERE upcoming = 0 ORDER BY start DESC;''').fetchone()[0]
        contests = {}
        page_overlapped = False
        for c in raw_contests.find_all("tr", {"data-contestid": True}):
            cid = int(c['data-contestid'])
            if last_contest == cid: page_overlapped = True
            td = c.find_all("td")
#           urls = [h.extract()['href'] for h in td[0].find_all('a', href=True)]
            title = td[0].text.lstrip().splitlines()[0]
            authors = [{'profile':a['href'],'class':a['class'][1],'title':a['title'],'name':a.text} for a in td[1].find_all('a', href=True)]
            start = td[2].find('span').text
            start = datetime.strptime(start, "%b/%d/%Y %H:%M").replace(tzinfo=self.tz_msk)
            length = td[3].text.strip()
            if upcoming:
                participants = 0
            else:
                participants = td[5].text.strip().lstrip('x')

            contests[cid] = {'title':title, 'authors':authors, 'start':start, 'length':length, 'participants':participants, 'upcoming':0}
            if write_db:
                cur.execute('INSERT or REPLACE INTO codeforces (cid, title, authors, start, length, participants, upcoming) VALUES (?, ?, ?, ?, ?, ?, ?)', (cid, title, json.dumps(authors), start, length, participants, upcoming))
        if write_db: self.db.commit()
        return page_overlapped

    def parse_div(self, title):
        r = []
        if 'Div.' in title:
            r += ['D']
            for i in range(1, 5):
                if re.compile('Div\. ?' + str(i)).search(title): r += [str(i)]
        elif 'Global' in title:
            r += ['G']
        return r

    def solved_problems(self):
        # TODO support directory hierachy. ex) 1600/a.cpp
        ret = {}
        for fn in listdir(path.expanduser(self.conf['solved_dir'])):
            t = path.splitext(fn)
            name = t[0]
            ext = t[1].lstrip('.')
            p = re.compile(r'^([0-9]+)([a-zA-Z])$').search(name)
            if ext and ext in self.conf['lang_ext'] and p and len(p.groups()) == 2:
                cid = int(p.group(1))
                level = p.group(2)
                if not cid in ret:
                    ret[cid] = [level]
                else:
                    ret[cid].append(level)
        return ret

    def show_contests(self, contests, check_solved=False, upcoming=False):
        solved_width = 0
        solved_contests = 0
        contests_nr = 0;
        if check_solved:
            solved_list = self.solved_problems()
            solved_width = max(map(len, self.conf['problem_range'].values()))+1
        for c in contests:
            cid = c[0]
            title = c[1]
            div = ''.join(self.parse_div(title))
            start = datetime.strptime(c[3], '%Y-%m-%d %H:%M:%S%z').astimezone(tz=None)
            length = c[4]
            if upcoming:
                participants = ''
            else:
                participants = ' x' + str(c[5])
            problems = ''
            solved_cnt = 0
            if check_solved and len(div) > 0:
                for l in self.conf['problem_range'][div[-1]]:
                    if cid in solved_list and l in solved_list[cid]:
                        solved_cnt += 1
                        problems += ' '
                    else:
                        problems += l.upper()
                if solved_cnt > 0 and solved_cnt == len(self.conf['problem_range'][div[-1]]):
                    solved_contests += 1
            countdown = ''
            if upcoming:
                d = start - datetime.now().astimezone(tz=None)
                h = d.seconds // 3600
                m = d.seconds // 60 % 60
                countdown = ' {}d+{:02d}:{:02d}'.format(d.days, h, m)

            if not check_solved or problems.strip():
                print("{:04d} {:<3} {:<{solved_width}}{:<{width}} {} ({}){}{}".format(cid, div, problems, title[:self.conf['title_width']], start.strftime("%Y-%m-%d %H:%M"), length, countdown, participants, width=self.conf['title_width'], solved_width=solved_width))
                contests_nr += 1
        if check_solved:
            print("[+] Solved {:d}/{:d} contests".format(solved_contests, contests_nr))

    def list_contest(self, args, upcoming=False):
        cur = self.db.cursor()
        update = False;
        last_modified = int(cur.execute('''SELECT strftime('%s', last_modified) FROM modifications WHERE site = 'codeforces';''').fetchone()[0])
        now = int(time())
        row_count = cur.execute('''SELECT COUNT(*) FROM codeforces''').fetchone()[0]
        if now - last_modified > 24 * 3600 or row_count == 0:
            update = True

        if args.force or update:
            print('[+] Update contests list', end='', flush=True)
            for page in range(1, self.conf['max_page']+1):
                print('.', end='', flush=True)
                page_path = '/contests/page/{:d}'.format(page)
                html = self.http_get(page_path)
                bs = BeautifulSoup(html, 'html.parser')
                table = bs.find_all("div", {"class": "datatable"})
                self.parse_list(table[0], upcoming=1, write_db=True)
                if self.parse_list(table[1], write_db=True): break
            print()

        if upcoming:
            print("[+] Current or upcoming contests")
            upcoming = cur.execute('''SELECT cid, title, authors, start, length, participants FROM codeforces WHERE upcoming = 1 ORDER BY start;''')
            self.show_contests(upcoming, upcoming=True)
        else:
            print("[+] Past contests")
            contests = cur.execute('''SELECT cid, title, authors, start, length, participants FROM codeforces WHERE upcoming = 0 ORDER BY start;''')
            self.show_contests(contests, check_solved=not args.all)

    def list_upcoming(self, args):
        self.list_contest(args, upcoming=True)

def main():
    parser = ArgumentParser(prog='Codeforces CLI', description="Codeforce CLI tool")
    parser.add_argument('--version', help="version", action='version', version='%(prog)s ' + __VERSION__)
    subparsers = parser.add_subparsers(title='commands', dest='command')
    cf = Codeforces()
    commands = {}

    _list = subparsers.add_parser('list', aliases=['l'], help="List contests", allow_abbrev=True)
    _list.add_argument('-f', '--force',  action='store_true', help="Update cache")
    _list.add_argument('-a', '--all',  action='store_true', help="Show all contests")
    _list.set_defaults(func=cf.list_contest)

    _list = subparsers.add_parser('upcoming', aliases=['u'], help="List upcoming contests", allow_abbrev=True)
    _list.add_argument('-f', '--force',  action='store_true', help="Update cache")
    _list.set_defaults(func=cf.list_upcoming)

    _solution = subparsers.add_parser('solution', aliases=['q'], help="Get problem's solutions", allow_abbrev=True)
    _solution.add_argument('cid', metavar='contestID', nargs='?', action='store', type=int)
    _solution.add_argument('level', metavar='contestID', nargs='?', action='store', type=str)
    _solution.set_defaults(func=cf.get_solutions)

    _info = subparsers.add_parser('info', aliases=['i'], help="Show contest info")
    _info.add_argument('cid', metavar='contestID', nargs='?', action='store', type=int)
    _info.set_defaults(func=cf.show_contest_info)

    _editorial = subparsers.add_parser('editorial', aliases=['d'], help="Search editorial links")
    _editorial.add_argument('cid', metavar='contestID', nargs='?', action='store', type=int)
    _editorial.set_defaults(func=cf.search_editorial)

    _open = subparsers.add_parser('open', aliases=['o'], help="Open codeforces URL")
    _open.add_argument('cid', metavar='contestID', nargs='?', action='store', type=int)
    _open.add_argument('level', metavar='contestID', nargs='?', action='store', type=str)
    _open.set_defaults(func=cf.open_url)

    args = parser.parse_args()
    if 'func' in args:
        args.func(args)
    else:
        parser.print_help()

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        logging.error("Exception", e)
